<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Example 1: Moving Average Models</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>##Overview</p>

<p>Spatial Prediction cares about making models based on spatially distributed data with respect to time.  It includes data structures, and skeletons of models in order to make it easy for users to quickly prototype new models on data in a wide variety of formats.</p>

<p>##Data</p>

<p>Suppose we want to use the following data to model rainfall over time in the various regions given below.</p>

<pre><code class="r">library(DAAG)
data(&quot;bomregions&quot;)
matrix_data = t(bomregions[1:8,c(10:17)])
colnames(matrix_data) = bomregions[1:8,1]
matrix_data
</code></pre>

<pre><code>##             1900   1901   1902   1903   1904   1905   1906   1907
## eastRain  429.98 500.12 315.33 694.09 564.86 443.11 735.26 585.13
## seRain    603.39 510.89 420.77 628.07 550.98 583.05 677.96 509.02
## southRain 375.39 314.01 283.64 420.83 388.11 325.70 422.12 357.48
## swRain    738.28 558.98 541.85 729.44 711.39 717.54 634.15 709.77
## westRain  399.90 323.07 362.57 377.11 417.96 253.67 336.66 339.78
## northRain 360.29 475.92 344.86 601.27 603.84 312.80 538.66 530.85
## mdbRain   412.67 364.65 255.85 524.88 448.40 427.93 610.43 436.35
## auRain    368.73 401.72 317.18 518.59 504.65 320.35 485.28 451.01
</code></pre>

<p>and suppose that we want to model the rainfall in the different regions over time.</p>

<h2>Example 1: Moving Average Models</h2>

<p>A relatively simple prediction model for space time data, is to predict the result for a location at time <code>t</code> to be the average of the values of that location at <code>k</code> previous times.  We will walk through the process of creating such a model.</p>

<p>####Data</p>

<p>For this model, all the data we need fits nicely into a space-time Matrix.</p>

<pre><code class="r">SpaceTimeMatrix &lt;- IncidenceMatrix$new(data=matrix_data)
</code></pre>

<p>The class <code>IncidenceMatrix</code> is an R6 class, and holds our data as well as several other pieces of information.  For a more detailed look into R6 classes, and how they differ from other ways of using R, see <code>vignette(&#39;R6 Classes&#39;,ForecastFramework)</code> or the <code>R6</code> package.  </p>

<p>####Model</p>

<p>For our model, we start by picking some model parameters.  For example, we can choose the number of time steps to go back <code>windowSize</code>.  Now lets walk through how to prototype this model:</p>

<pre><code class="r">MovingAverageModel &lt;- R6Class(
    inherit = Model,
</code></pre>

<p>We start by defining our new modeling class, <code>MovingAverageModel</code>  We want this to be recognized as a model by other code using <code>ForecastFramework</code>, so we  so we have it inherit from <code>Model</code>, one of the package classes.  The <code>Model</code> class defines some mandatory functions we need to extend.  These can be found by referencing the help page <code>?Model</code>, or by consulting the <code>vignette(&#39;ClassDiagram&#39;,&#39;ForecastFramework&#39;)</code>.</p>

<pre><code class="r">  private = list(
    window = NA,
    windowSize = 0
  )
</code></pre>

<p>The private section of the class is for aspects of the class we do not want the user to access directly.  These should be elements of the class which are called by other methods, and not directly.  Both methods (functions), and variables can be stored here.</p>

<pre><code class="r">    public = list(
</code></pre>

<p>The public section of the class is for anything the user should have direct access to.</p>

<pre><code class="r">        #&#39; @method initialize Create a new Moving Average Model
        #&#39; @param windowSize The size of window over which to do the moving average
        initialize = function(windowSize = 1){
            private$window = as.integer(1:windowSize)
            private$windowSize = as.integer(windowSize)
      }
</code></pre>

<p>The first method we modify is the initialization method.  This method gets called whenever we instantiate a <code>MovingAverageModel</code> with <code>MovingAverageModel$new()</code>.  See that we have passed <code>windowSize</code> to the model.  Also note the two commented lines right before the method.  These are documentation strings, and will be used to automatically document the class&#39; methods.  This function takes the window size, and assigns the two variables defined in the private section.  Note that we access them through the <code>private</code> keyword.  When accessing members of the class which are public, we will use the <code>self</code> keyword in the same way.</p>

<pre><code class="r">    #&#39; @method fit This function does nothing.
    #&#39; @param data This is included for compliance with Model.R
    fit = function(data){
      #The model is always fitted
      return()
    },
</code></pre>

<p>The fit method is supposed to take a data set, and use it to automatically configure model parameters.  However, our model is simple enough that no parameter modification is necessary.  So, we have the function do nothing.</p>

<pre><code class="r">        #&#39; @method predict Predict as much as possible from the new data
        #&#39; @param newdata The data to use when making predictions.
        predict = function(newdata){
          if(!(&#39;MatrixData&#39; %in% class(newdata))){
            stop(&quot;This operation requires matrix-like data&quot;)
          }
          # for debugging: see AbstractClasses::Generic::debug for details.
          if(&#39;predict&#39; %in% private$.debug){
            browser()
          }
          #This is an R6 specific thing.  We want to clone arguments before we use them, because
          #  otherwise we will also modify the original.
          newdata = newdata$clone(TRUE)
          #We&#39;ll add a column so the lagging works out correctly.
          #We can think of this as adding the prediction column to the data.
          newdata$addColumns(1)
          #We pre-allocate our return as another as a subclass of the Forecast class.
          #SimulatedIncidenceMatrix is the only one currently defined, so...
          #We&#39;re not doing anything stochastic, so we set the number of simulations to 1.
          rc = SimulatedIncidenceMatrix$new(newdata,nsim=1)
          #First we use the lag function of IncidenceMatrix to reogranize the data.
          #We want to use every row at every time step in the window.  The lag function allows us
          #to create new rows for these previous time steps.
          newdata$lag(private$window)
          #Since we added new rows, in particular for each old row we added private$windowSize new rows
          #  we divide.
          for(row in 1:newdata$nrow/private$windowSize){
            #The seq call is the index of all rows corresponding to the original row `row`
            #In other words, we take the mean of all rows corresponding to lagged versions of the original row
            #2 means take the mean of each column
            rc$mutate(rows=row,data=apply(newdata$mat[seq(row,newdata$nrow,private$windowSize),],2,mean))
          }
          return(IncidenceForecast$new(data=rc))
        }
</code></pre>

<p>predict is the main function of the class.  We first introduce extra rows to cover the whole window.  Then we take the average over the window for each row, and store that in the apropriate part of our output.  Notice here that the IncidenceMatrix class does most of the work, and we had very little manual steps.  Ideally, most of the prediction process is actions taken by the data on itself.  This allows us to make as few assumptions about the data as possible.</p>

<pre><code class="r">MovingAverageModel &lt;- R6Class(
    classname = &quot;MovingAverageModel&quot;,
    inherit = Model,
    private = list(
    window = NA,
    windowSize = 0
  ),
    public = list(
        initialize = function(windowSize = 1){
            private$window = as.integer(1:windowSize)
            private$windowSize = as.integer(windowSize)
      },
        #&#39; @method fit This function does nothing.
    #&#39; @param data This is included for compliance with Model.R
        fit = function(data){
      #This model is always fitted.
      return()
    },
        #&#39; @method predict Predict as much as possible from the new data
        #&#39; @param newdata The data to use when making predictions.
        predict = function(newdata){
          if(!(&#39;MatrixData&#39; %in% class(newdata))){
            stop(&quot;This operation requires matrix-like data&quot;)
          }
          # for debugging: see AbstractClasses::Generic::debug for details.
          if(&#39;predict&#39; %in% private$.debug){
            browser()
          }
          #We&#39;ll add a column so the lagging works out correctly.
          #We can think of this as adding the prediction column to the data.
          newdata$addColumns(1)
          #We pre-allocate our return as another as a subclass of the Forecast class.
          #SimulatedIncidenceMatrix is the only one currently defined, so...
          #We&#39;re not doing anything stochastic, so we set the number of simulations to 1.
          rc = SimulatedIncidenceMatrix$new(newdata,nsim=1)
          #First we use the lag function of IncidenceMatrix to reogranize the data.
          #We want to use every row at every time step in the window.  The lag function allows us
          #to create new rows for these previous time steps.
          newdata$lag(private$window)
          #Since we added new rows, in particular for each old row we added private$windowSize new rows
          #  we divide.
          for(row in 1:newdata$nrow/private$windowSize){
            #The seq call is the index of all rows corresponding to the original row `row`
            #In other words, we take the mean of all rows corresponding to lagged versions of the original row
            #2 means take the mean of each column
            rc$mutate(rows=row,data=apply(newdata$mat[seq(row,newdata$nrow,private$windowSize),],2,mean))
          }
          return(IncidenceForecast$new(data=rc,forecastTimes=sapply(1:rc$ncol,function(x){return(TRUE)})))
        }
    )
)
</code></pre>

<pre><code class="r">TheModel &lt;- MovingAverageModel$new(windowSize=3)
 TheModel$fit(data=SpaceTimeMatrix$subset(cols=-SpaceTimeMatrix$ncol,mutate=FALSE))
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r"> TheModel$predict(newdata=SpaceTimeMatrix$subset(cols=-SpaceTimeMatrix$ncol,mutate=FALSE))$mean()$mat
</code></pre>

<pre><code>##      1900 1901 1902     1903     1904     1905     1906       NA
## 1900   NA   NA   NA 385.5487 479.8575 484.6150 510.5337 516.1075
## 1900   NA   NA   NA 433.9225 447.0025 451.0900 512.1788 482.8813
## 1900   NA   NA   NA 436.5057 424.1557 531.9571 481.1900 502.6143
## 1900   NA   NA   NA 395.5800 449.2529 473.1514 520.1657 484.8000
## 1900   NA   NA   NA 435.8014 421.1357 436.8200 502.0543 455.0129
## 1900   NA   NA   NA 461.9833 424.7100 555.9317 507.1050 516.0300
## 1900   NA   NA   NA 371.2017 402.5550 433.4450 487.2700 459.9083
## 1900   NA   NA   NA 448.0067 428.4733 439.9633 543.4517 474.7383
</code></pre>

<p>The final output is a matrix with 5 columns, and 3 rows.  The rows correspond to the rows of our original matrix.  Notice that we predicted on only the first 4 columns of SpaceTimeMatrix, however the output has 5 columns.  The first 4 columns represent the same time steps as the first 4 columns of our original matrix, and the 5th column represents the time after the 4th column, which is the same time as the 5th column we chose not to predict on.  The first three columns are NA, because in order to compute those values, we need values not present in the current matrix.  To see how accurate we were, lets compare our results to the true values.</p>

<p>You may have also noticed that in order to extract the matrix, we use <code>TheModel$predict(...)$mean()$mat</code>.  This is because the prediction is its own object.  If we print it to screen, we see:</p>

<pre><code class="r">prediction &lt;- TheModel$predict(newdata=SpaceTimeMatrix$subset(cols=-SpaceTimeMatrix$ncol,mutate=FALSE))
prediction
</code></pre>

<pre><code>## &lt;IncidenceForecast&gt;
##   Inherits from: &lt;SimulatedForecast&gt;
##   Public:
##     binDist: function (cutoffs) 
##     clone: function (deep = FALSE) 
##     data: active binding
##     debug: function (string) 
##     forecastMadeTime: active binding
##     forecastTimes: active binding
##     initialize: function (data = SimulatedIncidenceMatrix$new(), forecastTimes = c()) 
##     mean: function () 
##     median: function () 
##     model: active binding
##     nsim: active binding
##     quantile: function (alphas) 
##     sample: active binding
##     undebug: function (string) 
##   Private:
##     .data: SimulatedIncidenceMatrix, AbstractSimulatedIncidenceMatrix, ArrayData, MatrixData, DataContainer, Generic, R6
##     .debug: 
##     .forecastMadeTime: 2017-06-27 18:01:19
##     .forecastTimes: TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
##     .model: Generic, R6
##     .nsim: 0
##     checkType: function (name, val, type = &quot;self&quot;) 
##     defaultAbstract: function (...) 
##     defaultActive: function (name, type, value)
</code></pre>

<p>We see that this object is another R6 class, <code>IncidenceForecast</code> containing information about when the prediction was created, which columns are predicted, and other information.  We can use some of the features of our IncidenceForecast to calculate.  For example, here is the absolute error of the mean prediction.</p>

<pre><code class="r">truth &lt;- SpaceTimeMatrix
abs_error &lt;- abs(prediction$mean()$mat-truth$mat)
abs_error
</code></pre>

<pre><code>##      1900 1901 1902      1903       1904     1905      1906        NA
## 1900   NA   NA   NA 308.54125  85.002500  41.5050 224.72625  69.02250
## 1900   NA   NA   NA 194.14750 103.977500 131.9600 165.78125  26.13875
## 1900   NA   NA   NA  15.67571  36.045714 206.2571  59.07000 145.13429
## 1900   NA   NA   NA 333.86000 262.137143 244.3886 113.98429 224.97000
## 1900   NA   NA   NA  58.69143   3.175714 183.1500 165.39429 115.23286
## 1900   NA   NA   NA 139.28667 179.130000 243.1317  31.55500  14.82000
## 1900   NA   NA   NA 153.67833  45.845000   5.5150 123.16000  23.55833
## 1900   NA   NA   NA  70.58333  76.176667 119.6133  58.17167  23.72833
</code></pre>

</body>

</html>
